# 14. 취약한 패스워드 복구 (Weak Password Recovery)

## 1. 개요 (Overview)
- **정의**: 패스워드 분실 시, 신원 확인 절차가 미흡하거나 복구 로직의 허점을 이용해 비인가자가 타인의 비밀번호를 획득 또는 재설정할 수 있는 취약점.
- **위험도**: **상 (High)** / 계정 탈취(Account Takeover) 직결
- **영향**:
    - **계정 무단 탈취**: 공격자가 피해자의 비밀번호를 몰라도 재설정하여 로그인 가능.
    - **2차 피해**: 탈취된 계정을 이용한 개인정보 유출 및 금전적 피해.

> **💡 핵심 원리 (Logic Flaw)**
>
> "열쇠를 잃어버렸다고 하니, 열쇠공(서버)이 신분증 확인도 제대로 안 하고(검증 미흡) 새 열쇠를 아무나한테 던져주거나(로직 허점), 자물쇠 비밀번호를 큰 소리로 알려주는 격(정보 노출)."

---

## 2. 공격 메커니즘 (Attack Vector)

### 시나리오 1: 본인 확인 정보 추측 (Knowledge-Based Attack)
**1. 정보 수집 (OSINT)**
- 해커가 SNS 등을 통해 피해자의 출신 학교, 생일, 반려동물 이름 등을 수집.

**2. 비밀번호 찾기 시도**
- "질문: 졸업한 초등학교는?" -> "답변: OO초등학교" 입력.
- **취약점**: 질문/답변 방식은 답이 정해져 있고 유추가 쉬워 보안성이 매우 낮음.

### 시나리오 2: 로직 우회 및 응답값 변조 (Logic Bypass) - *26기 중점*
**1. 인증번호 요청 및 오입력**
- 해커가 피해자 ID로 인증번호 발송 요청 후, 틀린 번호를 입력하고 요청 전송.

**2. 응답값 변조 (Response Manipulation)**
- 프록시 도구(Burp Suite)로 서버 응답 패킷을 가로챔.
- 서버가 보낸 `{"status": "fail", "code": 400}`을 `{"status": "success", "code": 200}`으로 변조하여 브라우저에 전달.

**3. 강제 진행**
- 클라이언트(브라우저)는 성공한 줄 알고 "비밀번호 재설정 페이지"를 보여줌.
- 해커가 새 비밀번호를 입력하고 변경 요청을 보내면, 서버가 세션이나 토큰 검증 없이 DB를 업데이트해버림.

---

## 3. 취약한 코드 vs 안전한 코드 (Java/Spring)

핵심은 **"비밀번호를 알려주지 말 것"**과 **"검증은 끝까지 서버에서 할 것"**.

### ❌ 취약한 코드 (패스워드 직접 노출)
> 최악의 패턴. DB에서 패스워드를 조회하여 화면에 출력하거나 이메일로 전송. (비밀번호가 평문/복호화 가능하게 저장되었다는 뜻이기도 함.)

```java
// PasswordSearchController.java
@RequestMapping("/findPw")
public String findPw(String userId, Model model) {
    // 본인확인 로직 대충 통과했다고 가정
    MemberVO member = memberService.selectMember(userId);
    
    // 취약점: 비밀번호를 그대로 보여줌
    model.addAttribute("msg", "회원님의 비밀번호는 " + member.getUserPw() + " 입니다.");
    return "resultPage";
}
```

### ❌ 취약한 코드 (파라미터 변조 가능)
인증 성공 후 리다이렉트할 때 ID를 평문 파라미터로 넘기는 경우.
```java
// 인증 성공 시 이동
return "redirect:/user/resetPw?id=" + userId;
```
공격: 해커가 URL의 id=victim을 id=admin으로 바꿔서 접속하면 관리자 비밀번호 변경 페이지가 뜸.

### ✅ 안전한 코드 (임시 토큰 & 서버 검증)
난수화된 임시 토큰(Nonce)을 생성하여 검증하고, 비밀번호는 무조건 재설정만 가능하도록 구현.
```java
// 1. 토큰 생성 및 이메일 발송
String token = UUID.randomUUID().toString();
// Redis 등에 저장 (Key: token, Value: userId, TTL: 5분)
redisTemplate.opsForValue().set("reset_token:" + token, userId, 5, TimeUnit.MINUTES);
emailSender.send(userEmail, "비밀번호 재설정", "[domain.com/reset?token=](https://domain.com/reset?token=)" + token);

// 2. 재설정 요청 처리 (ResetController.java)
@PostMapping("/changePw")
public String changePw(@RequestParam String token, @RequestParam String newPw) {
    // 서버 저장소(Redis)에서 토큰 유효성 검증
    String userId = (String) redisTemplate.opsForValue().get("reset_token:" + token);
    
    if (userId == null) {
        throw new SecurityException("유효하지 않거나 만료된 토큰입니다.");
    }
    
    // 비밀번호 암호화 후 변경
    memberService.updatePassword(userId, passwordEncoder.encode(newPw));
    
    // 토큰 즉시 폐기 (재사용 방지)
    redisTemplate.delete("reset_token:" + token);
    
    return "success";
}
```


## 4. 대응 방안 (Remediation Checklist)
1. 기존 패스워드 노출 금지:

어떤 경우에도 패스워드를 화면에 표시하거나 이메일/SMS로 전송하지 않는다. (반드시 재설정(Reset) 로직 수행)

2. 안전한 인증 수단 적용:

유추 가능한 '질문/답변' 방식을 제거하고, 소유 기반 인증(이메일, SMS, OTP)을 적용한다.

3. 임시 토큰(Nonce) 활용:

비밀번호 변경 페이지 접근 권한을 제어하기 위해 예측 불가능한 난수(UUID 등) 토큰을 사용한다.

토큰은 **1회성(One-time)**이어야 하며, 짧은 유효 시간(3~5분)을 설정한다.

4. 단계별 세션 검증 (State Check):

인증 단계(1단계)에서 성공했다는 사실을 서버 세션에 기록하고, 변경 단계(2단계)에서 그 세션 값이 존재하는지 반드시 다시 확인한다. (단순 URL 접근 차단)

## 5. 심화
1) "비밀번호만 안 보여주면 안전한가?" (21년도 기준의 맹점)

취약점 진단을 처음 공부할 때 [취약한 패스워드 복구] 항목을 보면, 주로 "비밀번호가 화면에 뜨는지" 혹은 **"이메일로 전송되는지"**에 집중하게 된다. 21년도 주요정보통신기반시설 가이드라인도 이 부분(정보의 기밀성)을 중점적으로 기술하고 있다.

하지만 여기서 의문이 생긴다. "비밀번호를 안 보여주고, 재설정 페이지만 띄워주면 무조건 안전한 걸까?"

해커 입장에서는 굳이 기존 비밀번호를 알 필요가 없다. 내가 원하는 비밀번호로 바꿀 수만 있다면(Reset) 그게 곧 계정 탈취이기 때문이다.

2) "문은 잠갔는데, 열쇠 구멍은 검사 안 하나?" (로직의 허점)

많은 웹 사이트들이 "인증번호 발송 -> 확인 -> 비밀번호 변경"이라는 3단계를 거친다. 개발자들은 각 단계의 **화면(View)**을 만드는 데 집중하지만, 보안 담당자는 그 사이를 오가는 **데이터(Packet)**를 의심해야 한다.

맹점 1 (응답값 변조): 인증번호가 틀렸다고 서버가 False를 보냈는데, 프록시 툴로 True로 바꿔서 브라우저한테 주면? 브라우저는 멍청하게 "어? 맞았네? 다음 페이지(비밀번호 변경) 열어줄게"라고 반응한다.

맹점 2 (파라미터 변조): 내 아이디로 인증을 다 통과했다. 마지막에 "비밀번호 변경해줘"라는 요청을 보낼 때, 슬쩍 id=admin으로 바꿔서 보내면? 서버가 "아까 인증한 사람이랑 지금 요청한 사람이랑 같은 사람 맞아?"라고 확인 안 하면 뚫린다.