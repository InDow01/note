# 12. 약한 문자열 강도 (Weak Password Strength)

## 1. 개요 (Overview)
- **정의**: 사용자 계정의 비밀번호 설정 시 영문, 숫자, 특수문자 등을 혼합하지 않거나 길이가 짧아, 공격자가 **무차별 대입(Brute Force)**이나 **사전 대입(Dictionary Attack)** 공격으로 쉽게 비밀번호를 추측할 수 있는 취약점.
- **위험도**: **상 (High)**
- **영향**:
    - 손쉬운 계정 탈취.
    - 탈취된 계정을 이용한 내부 시스템 침투 및 정보 유출.

> **💡 핵심 원리**
> "비밀번호를 `1234`로 하면 1초 만에 뚫리지만, `P@ssw0rd!23`으로 하면 슈퍼컴퓨터로도 몇백 년이 걸리게 만드는 **확률 게임**."

---

## 2. 공격 메커니즘 (Attack Vector)

### ① 무차별 대입 공격 (Brute Force Attack)
- 가능한 모든 경우의 수(a, b, c... aa, ab...)를 프로그램으로 다 넣어보는 방식.
- 비밀번호가 짧을수록 기하급수적으로 빨리 뚫림.

### ② 사전 대입 공격 (Dictionary Attack)
- 사람들이 자주 쓰는 단어(`love`, `admin`, `password`, `123456`)를 사전에 모아두고 대입.
- 복잡성(특수문자 혼합)이 없으면 쉽게 뚫림.

### ③ 레인보우 테이블 (Rainbow Table) - 저장소 공격
- 해커가 DB를 털었을 때, 비밀번호가 암호화되어 있어도 **미리 계산된 해시값 표(Rainbow Table)**와 비교하여 원래 암호를 찾아냄.
- 이를 막기 위해 **Salt**가 필수적임.

---

## 3. 취약한 코드 vs 안전한 코드 (Java)

이 항목은 **정책(Policy)**을 코드로 강제하는 것이 핵심.

### ❌ 취약한 코드 (검증 없음)
> 길이 제한만 있고 복잡성 체크가 없음.

```java
String password = request.getParameter("password");

// "1234" 같은 비밀번호도 통과됨
if (password.length() < 4) {
    alert("4자리 이상 입력하세요.");
}
```

### ✅ 안전한 코드 (정규식 검증 + 암호화 저장)

> KISA 권고 기준:
>
>3종류(영대소문자, 숫자, 특수문자) 조합 시 8자리 이상.
>
>2종류 조합 시 10자리 이상.

Step 1: 정규표현식(Regex)을 이용한 복잡성 검증
```java
// 영문, 숫자, 특수문자 포함 8자리 이상 정규식
String regex = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[$@$!%*#?&])[A-Za-z\\d$@$!%*#?&]{8,}$";

if (!password.matches(regex)) {
    throw new SecurityException("비밀번호는 영문, 숫자, 특수문자를 포함하여 8자리 이상이어야 합니다.");
}
```

Step 2: 안전한 저장 (Salt + Hash) 비밀번호는 평문으로 저장하면 안 됨. **단방향 해시 함수(SHA-256 등)**를 쓰되, Salt를 쳐야 함.

```java
// Spring Security의 BCryptPasswordEncoder 사용 권장 (표준)
// 내부적으로 랜덤 Salt를 생성하여 해시를 만듦
String encodedPassword = new BCryptPasswordEncoder().encode(password);
userDao.save(id, encodedPassword);
```

> salt? 소금이요?
>
>password + salt(랜덤값) 을 넣어서 원래의 원래의 맛을 찾을 수 없게하는 기법


## 4. 대응 방안 (Remediation)
패스워드 복잡성 강제:

회원가입 및 비밀번호 변경 시 **자바스크립트(Front)**와 서버(Back) 양쪽에서 정규식을 통해 유효성을 검증한다.

로그인 실패 횟수 제한 (Account Lockout):

5회 이상 틀리면 계정을 잠그거나, 캡차(CAPTCHA)를 띄워 무차별 대입을 막는다.

안전한 암호화 저장:

비밀번호는 복호화가 불가능한 **단방향 해시(One-way Hash)**로 저장한다.

반드시 **Salt(무작위 문자열)**를 추가하여 레인보우 테이블 공격을 무력화한다.

## 5. 심화

1. salt가 필수?

앞에서도 이야기 했듯이 필자가 이해하는 보안이란, 해커가 재화를 사용하게 하는 것임. 
여기서 말하는 재화란 시간, 노력과 같은 비용도 재화라고 표현함. 그러니까 해커가 시간이 오래걸리고 해킹이 어렵게 만들어야 함. 그런 측면에서 소금을 치는 행위는 개발자에게 굉장한 가성비임.

예로, DB에 비밀번호를 소금없이 저장한다고 가정하자. 

- DB 저장 (Salt 없음):

철수: 1234 $\rightarrow$ 해시값: a1b2c3d4

영희: 1234 $\rightarrow$ 해시값: a1b2c3d4

해킹 발생: 해커가 DB를 털었는데, 두 사람의 해시값이 똑같네?

해커: "어? a1b2c3d4는 내가 미리 계산해둔 표(Rainbow Table)를 보니까 1234네? 둘 다 털렸다."

즉, 같은 비밀번호를 쓰는 사람들의 암호문이 똑같이 나와서, 한 번에 다 털리는 문제가 발생.

- DB 저장 (Salt있음) :

철수: 1234 + (zX94)(철수소금)$\rightarrow$ 해시값: 9q8w7e...

영희: 1234 + (kL2m)(영희소금) $\rightarrow$ 해시값: 1z2x3c...

결과적으로 비밀번호 원문은 같지만, 해시값은 전혀 다른값이 되어버림.


2. 그러면 salt는 어디에?

DB에 저장되어짐. Password | Salt 의 형태로.

$\rightarrow$ 그러면 DB 털리면? 

DB는 안털려야죠. 12번 항목인 약한 문자열 강도 취약점은 BruteForcing 취약점에 대한 항목임. 

사실 방법은 더 있다. 후추까지 뿌리는거다. 예를 들어 서버 내부 설정파일에 고정적인 후추가 있다면 이와 합쳐서 해싱해버리면 서버내부를 털지 않는 이상 복호화가 불가능하다. BruteForcing이 시도되었을 때 해커가 전기세가 더 나오게 하는 것이 목적이므로 해당 방법도 고려해 볼 만 하다.