# 4. 운영체제 명령어 실행 (OS Command Injection)

## 1. 개요 (Overview)
- **정의**: 웹 애플리케이션이 외부 입력값을 검증하지 않고 시스템 쉘(Shell) 명령어의 파라미터로 전달할 때 발생하는 취약점.
- **위험도**: **상 (High)** / 시스템 장악 가능 (RCE: Remote Code Execution).
- **발생 원리**: 공격자가 **메타 문자(Meta Character)**를 이용하여 기존 명령어를 종료하거나 연결하고, 악의적인 시스템 명령어를 주입함.

> **💡 주요 메타 문자**
> - `;` (명령어 구분자)
> - `&`, `&&` (백그라운드 실행, 논리 연산자)
> - `|`, `||` (파이프, 논리 연산자)
> - `$()` , `` ` `` (명령어 치환)

---

## 2. 공격 메커니즘 (Attack Vector)

### 시나리오: Ping 테스트 기능
사용자로부터 IP를 입력받아 `ping`을 날리는 기능이 있다고 가정.

1. **정상 요청**
   - 입력값: `8.8.8.8`
   - 서버 실행: `ping 8.8.8.8`

2. **공격 요청**
   - 입력값: `8.8.8.8; cat /etc/passwd`
   - 서버 실행:
     ```bash
     ping 8.8.8.8      # 1. 핑 실행됨
     ;                 # 2. 명령어 구분
     cat /etc/passwd   # 3. 패스워드 파일 열람 실행됨 (정보 유출)
     ```

---

## 3. 취약한 코드 vs 안전한 코드 (Java)

### ❌ 취약한 코드 (Vulnerable)
> `Runtime.exec`에 입력값을 문자열 결합(+)으로 전달하여 쉘이 개입할 여지를 줌.

```java
public void pingTest(String ip) {
    try {
        // 입력값 검증 없음
        String cmd = "ping -c 3 " + ip;
        
        // 쉘이 메타 문자를 해석하여 다중 명령어 실행 가능
        Process p = Runtime.getRuntime().exec(cmd);
        
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
### ✅ 안전한 코드 (Secure Coding)
> **핵심 전략 2가지 적용**
> 1. **White-List 검증**: 정규식을 통해 허용된 포맷(IP)인지 확인.
> 2. **ProcessBuilder 사용**: 명령어와 인자(Argument)를 분리하여 쉘 해석 방지.

```java
public void pingTestSecure(String ip) {
    // [Step 1] 입력값 검증 (White-list)
    // IPv4 형식이 맞는지 정규식으로 체크
    String regex = "^\\d{1,3}(\\.\\d{1,3}){3}$";
    if (!ip.matches(regex)) {
        throw new SecurityException("유효하지 않은 IP 형식입니다.");
    }

    try {
        // [Step 2] ProcessBuilder를 통한 인자 분리
        // 쉘을 거치지 않고 실행 파일에 인자만 전달됨
        List<String> commands = new ArrayList<>();
        commands.add("ping");
        commands.add("-c");
        commands.add("3");
        commands.add(ip); // 여기에 "; cat"이 들어와도 단순 문자열로 인식됨

        ProcessBuilder pb = new ProcessBuilder(commands);
        Process p = pb.start();
        
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```
### Process Builder?
>자바(Java)에서 외부 프로세스(운영체제 명령어, 쉘 스크립트 등)를 생성하고 제어하기 위해 사용되는 클래스

Runtime.exec -> ProcessBuilder 를 이용한 input의 문자열처리가 중요함.
입력값에 대한 정규식 화이트리스트 검증을 선행하고, 명령어와 인자를 구조적으로 분리.

---
### 예상질문
>1. Process Builder가 Runtime.exec 보다 안전한 기술인 이유

가장 큰 차이는 쉘의 개입 유무다. 다음은 인자(Argument) 파싱처리이다.
기존 Runtime.exec 방식은 입력된 문자열을 불완전하게 파싱하기 때문에, 공격자가 ;(세미콜론) 과 같은 메타문자를 주입하면 쉘이 이를 명령어로 해석하여 실행하는 구조적 취약점이 존재한다.

하지만 Process Builder 방식을 사용하면 인자를 List 형태로 명확히 분리하여 OS 커널에 직접 전달한다. 이 과정에서 쉘에 전달할 뿐 사용자가 직접 쉘에 명령어를 전달할 수 없으며, 사용자의 입력 구문은 단순 문자열로 처리된다. 메타 문자를 포함시켜 입력 구문을 조작하더라도 오류가 날 뿐 실행되어지지 않는다. 

>2. Process Builder를 사용하면 100% 안전한가요?

아니다. Process Builder를 이용하더라도, sh 나 cmd에 직접 전달하게 되면 메타 문자를 포함시켜서 조작이 가능하다. 그러므로, 쉘 직접 호출이 아닌 사용해야만 하는 명령어를 특정하여 코딩하는게 중요하다.

```java
// 쉘을 직접 호출하고, 사용자 입력(input)을 통째로 넘기면 안 됨!
ProcessBuilder pb = new ProcessBuilder("sh", "-c", "ping " + input);
// input에 "; ls"가 들어오면 쉘이 해석해서 실행됨.

// 쉘을 부르지 않고, 실행 파일(ping)을 직접 부르고 인자를 따로 줌
ProcessBuilder pb = new ProcessBuilder("ping", "-c", "3", input);
```

>3. 그러면 2번  처럼 코딩하면 100% 안전한가요?

결론부터 말하면 아님. 일단 Ping은 뭐 100% 안전할 수 있음. 또한, Shell Injection은 안전할 수 있으나, Argument Injection은 다른 문제임. 가이드라인 상 OS Command Injection은 방어 가능. 

예를 들어서 find 명령어를 사용해야 하는 경우,
```java
// 사용자가 파일명(input)을 입력하면 find로 찾는 로직
new ProcessBuilder("find", ".", "-name", input);
```
다음과 같이 코딩했다고 가정하겠음. ProcessBuilder는 input을 명령어로 해석하지 않음. 

(input) 으로 -exec rm -rf {} ; 를 삽입하면 find 기능자체가 사라짐.

그러면 어케 해결할까요? ㅠㅠ

1. OS 명령어 최소화. 예를 들어서 find 옵션을 ls 로 찾은다음에 자바에서 결과값을 조사하여 찾아주는 방식
2. 쉘을 하나 만들어라. 서버에 safe.sh 라는 쉘을 만들어서 최소권한을 주고 수정불가로 만들기.

```java
new ProcessBuilder("/scripts/safe_search.sh", inputKeyword, OutputFile);
```
이런식으로 안전한 쉘을 두고, 사용자에게 제공하는 방식

```java
//safe_search.sh
#!/bin/bash

# $1 : 첫 번째 인자 (Java에서 보낸 inputKeyword)
# $2 : 두 번째 인자 (Java에서 보낸 OutputFile)


ls -l /var/log | grep "$1" > "$2"

#실행권한 부여
chmod +x /scripts/safe_search.sh
# 소유자를 root로 변경 (웹 계정이 아님)
chown root:root /scripts/safe_search.sh

# 권한을 755로 설정 (소유자만 쓰기 가능, 나머지는 읽기/실행만 가능)
chmod 755 /scripts/safe_search.sh
```

> 4. Argument Injection ? 해당 문제와 관련해서 설명해봐라.

일단 두 Injection의 차이를 이해해야 함. 

### Command Injection VS Argument Injection 

#### Command Injection
쉘(Shell)에 다른 명령어를 실행하게 하는 것(의도와 다르게)

#### Argument Injection

프로그램(Binary)을 속여서 이상한 옵션(Flag)을 실행하게 하는 것

Process Builder는 입력값을 "명령어"가 아닌 "텍스트 덩어리"로 보냄. 그래서 ; &같은 메타문자는 무시됨. 하지만, -(하이픈)으로 시작되면 옵션이라고 착각하게 됨.

```java
new ProcessBuilder("find", ".", "-name", userInput);
// 사용자 입력 : report.txt
// 실제 실행 : find . -name report.txt
// 결과 report.txt 를 보여줌. -> 정상 
```

###  공격상황
```java
new ProcessBuilder("find", ".", "-name", userInput);

// 사용자 입력 : -exec id ;
// 실제 실행 find . -name -exec id ;
// -name이 없으면 에러가 될 수도 있지만, 앞의 인자를 닫고 공격하면 됨. 구조상의 편의를 위해 무시. 
```
결과 적으로 id 명령어가 실행되어 id 정보가 탈취되어지고 RCE가 가능했음.
### 그럼 어케막음?
입력값 검증 (White-List)
파일명이나 IP 주소 같은 값을 하이픈(-)으로 못하게 막음
- 예: ^[a-zA-Z0-9._]+$ (알파벳, 숫자, 점, 밑줄만 허용)

옵션 끝 구분자 (Double Dash -- ) 사용 - 테크닉 
리눅스 명령어는 더블 대시 뒤에 오는 값을 옵션이 아닌 단순 인자값으로 처리함.

#### 취약한 코드
```java
new ProcessBuilder("find", ".", "-name", userInput);
```
#### 안전한 코드 
```java
// -- 뒤에 오는 건 무조건 파일명으로 인식해라!
new ProcessBuilder("find", ".", "-name", "--", userInput);
```

---






## 핵심 요약 (Key Takeaways)

OS Command Injection 취약점의 본질은 "데이터(User Input)와 명령어(Command)가 분리되지 않아서 발생"하는 것입니다. 이를 해결하기 위한 제 접근 방식은 다음과 같습니다.

1.  **구조적 분리 (Separation):**
    - `Runtime.exec` 대신 `ProcessBuilder`를 사용하여, 사용자 입력값이 쉘에 의해 해석되지 않고 단순 인자(Argument)로만 전달되도록 강제합니다.

2.  **심층 방어 (Defense in Depth):**
    - ProcessBuilder가 막지 못하는 **Argument Injection** 가능성까지 고려하여, 입력값이 하이픈(`-`)으로 시작하지 못하도록 **White-list 정규식 검증**을 수행합니다.
    - 리눅스 명령어의 표준인 **Double Dash(`--`)** 기법을 적용하여 인자 해석을 강제로 중단시킵니다.

3.  **최소 권한 원칙 (Least Privilege):**
    - 복잡한 로직이 필요한 경우, Java 코드 내에서 해결하거나 **"수정 권한이 제거된(Root only)"** 쉘 스크립트만을 호출하도록 하여, 만에 하나 발생할 수 있는 공격 피해를 시스템 전체로 확산되지 않도록 격리합니다.

