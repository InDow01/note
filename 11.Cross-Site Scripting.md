# 11. 크로스사이트 스크립팅 (Cross-Site Scripting, XSS)

## 1. 개요 (Overview)
- **정의**: 공격자가 웹 페이지에 **악의적인 스크립트(JavaScript 등)**를 삽입하여, 이를 열람하는 **다른 사용자(Victim)의 브라우저에서 스크립트가 실행**되도록 하는 취약점.
- **위험도**: **상 (High)**
- **영향**:
    - **세션 하이재킹 (Session Hijacking)**: 사용자의 세션 쿠키를 탈취하여 로그인 없이 계정 도용.
    - **피싱 (Phishing)**: 가짜 로그인 창을 띄워 비밀번호 입력 유도.
    - **키로깅 (Keylogging)**: 사용자가 입력하는 키보드 값을 가로챔.
    - **악성코드 다운로드**: 접속 시 자동으로 악성 프로그램 다운로드 (Drive-by Download).

> **💡 핵심 원리**
> "공격자가 작성한 데이터(Text)를, 브라우저가 코드(Script)로 오인해서 실행하는 것."
> (원래 CSS라고 불러야 맞겠지만, 스타일시트와 헷갈려서 XSS가 됨.)

---

## 2. 공격 메커니즘 및 유형 (Attack Vectors)


### ① 저장형 XSS (Stored / Persistent XSS) - 가장 위험
- **원리**: 악성 스크립트가 서버의 **DB(게시판, 댓글, 프로필 등)에 저장**됨.
- **과정**:
    1. 공격자가 게시판에 `<script>alert(document.cookie)</script>` 글 작성.
    2. 일반 사용자가 그 글을 클릭(조회).
    3. DB에 있던 스크립트가 사용자 브라우저로 전송되어 실행됨.
- **특징**: 한 번 심어두면 방문하는 모든 사람이 감염됨.

### ② 반사형 XSS (Reflected / Non-persistent XSS)
- **원리**: 악성 스크립트가 서버에 저장되지 않고, **URL 파라미터**를 통해 반사되어 즉시 실행됨.
- **과정**:
    1. 공격자가 악성 링크 생성 (`http://site.com/search?keyword=<script>...</script>`).
    2. 이메일이나 문자로 링크 유포 (피싱).
    3. 피해자가 링크를 클릭하면, 서버가 검색어를 화면에 그대로 보여주면서 스크립트 실행.
- **특징**: 링크를 클릭해야만 터짐.

### ③ DOM 기반 XSS (DOM-based XSS)
- **원리**: 서버를 거치지 않고, **브라우저 내의 자바스크립트 처리 과정(DOM 조작)**에서 발생하는 취약점.
- **특징**: 서버 로그에 남지 않아 탐지가 어려움. (`document.write`, `innerHTML` 사용 시 주의)

---

## 3. 취약한 코드 vs 안전한 코드 (Java/JSP)

XSS 방어의 핵심은 **"입력값 검증"**보다 **"출력값 인코딩(Output Encoding)"**이 훨씬 중요.

### ❌ 취약한 코드 (그대로 출력)
> 사용자 입력값을 필터링 없이 화면에 뿌림.

```jsp
<%
    String keyword = request.getParameter("keyword");
%>
검색 결과: <%= keyword %>
```

### ✅ 안전한 코드 (HTML Entity 변환)
특수문자(`<`, `>`, `&`, `"`, `'`)를 HTML 엔티티 코드로 변환(치환)하여, 브라우저가 스크립트 태그가 아닌 단순 문자열로 인식하게 만듦.

방법 1: JSTL (Standard Tag Library) 사용 (가장 권장) JSTL의 <c:out> 태그는 기본적으로 XML Escaping 처리를 수행함.

```java
<%@ taglib prefix="c" uri="[http://java.sun.com/jsp/jstl/core](http://java.sun.com/jsp/jstl/core)" %>

검색 결과: <c:out value="${param.keyword}" />
```

방법 2: 시큐어 코딩 라이브러리 (Naver Lucy XSS Filter 등) 스마트 에디터(HTML 허용 게시판)의 경우, 무조건 다 막으면 글 꾸미기가 안 됨. 이럴 땐 허용할 태그만 남기는 화이트리스트 필터를 씀.

```java
// Lucy XSS Filter 적용 예시
XssSaxFilter filter = XssSaxFilter.getInstance("lucy-xss-sax.xml");
String clean = filter.doFilter(dirtyHTML);
```

방법 3: 직접 변환 함수 (비추천 - 실수 가능성 있음)

```java
public static String xssFilter(String str) {
    if (str == null) return null;
    return str.replaceAll("&", "&amp;")
              .replaceAll("<", "&lt;")
              .replaceAll(">", "&gt;")
              .replaceAll("\"", "&quot;")
              .replaceAll("'", "&#x27;");
}
```


## 4. 대응 방안 (Remediation Checklist)

1. 출력값 인코딩 (Output Encoding) [필수]: 데이터를 브라우저로 보낼 때 반드시 HTML Entity로 변환한다.

2. 입력값 검증 (Input Validation): 입력 단계에서 `<script>`, `javascript`: 같은 위험한 문자열을 거부한다.

3. HttpOnly 플래그 설정 [완화책]:

XSS가 터져도 **세션 쿠키(JSESSIONID)**는 못 털어가게 막는 설정.

document.cookie로 접근이 불가능해짐.

설정법 (web.xml):
```xml
<session-config>
    <cookie-config>
        <http-only>true</http-only>
        <secure>true</secure> </cookie-config>
</session-config>
```

4. CSP (Content Security Policy) 적용: 헤더 설정을 통해 허용된 도메인의 스크립트만 실행되도록 제한.

## 5. 심화

1. XSS vs CSRF

늘 나오는 주제다. 바로 다음 항목이 CSRF인 이유가 아닐까 싶다.

XSS: 공격 대상이 **Client(사용자)**. 사용자가 **"악성 스크립트를 실행"**하게 만드는 것이 목적. (사이트를 믿은 사용자가 당함)

CSRF: 공격 대상이 **Server(서버)**. 사용자의 권한을 도용해서 **"원치 않는 요청(글쓰기, 송금 등)을 서버로 전송"**하게 만드는 것이 목적. (사용자를 믿은 서버가 당함)

2. HTTPOnly

보안 공부 초기에는 해당 설정을 사용하면 막히는 줄 알았다. 하지만 HttpOnly는 자바스크립트로 쿠키를 훔치는 것만 막아줄 뿐, XSS 자체를 막지는 못한다. 공격자는 쿠키 탈취 대신 피싱 창을 띄우거나, 악성코드를 다운로드하게 만드는 등 다른 공격을 할 수 있다. 따라서 근본적인 해결책은 Output Encoding이다.

3. DOM Based XSS 방어 (Frontend)

서버에서 치환하더라도 프론트엔드 코드(js)에서 다시 HTML로 해석하면 뚫린다.

- ❌ 취약: div.innerHTML = content; (태그가 실행됨)

- ✅ 안전: div.textContent = content; (단순 텍스트로 들어감)