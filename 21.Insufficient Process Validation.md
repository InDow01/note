# 21. 불충분한 프로세스 검증 (Insufficient Process Validation)

## 1. 개요 (Overview)
- **정의**: 웹 애플리케이션의 비즈니스 로직이 순차적인 단계(Step 1 -> Step 2 -> Step 3)로 이루어져 있을 때, 사용자가 특정 단계를 건너뛰고 최종 단계로 접근해도 서버가 이를 검증하지 않고 허용하는 취약점.
- **위험도**: **상 (High)** / 금전적 손실 및 권한 우회
- **영향**:
    - **결제 우회**: 결제 요청(PG사 연동) 단계를 건너뛰고, 주문 완료 페이지로 바로 접근하여 공짜로 물건 구매.
    - **인증 절차 우회**: 본인 확인 절차를 생략하고 비밀번호 변경 또는 회원가입 완료.

> **💡 핵심 원리 (Flow Bypass)**
>
> "놀이공원에서 표 사는 줄(Step 1)을 서지 않고, 몰래 출구(URL)를 통해 들어와서 바로 롤러코스터(Step 3)에 앉아버리는 행위."

---

## 2. 공격 메커니즘 (Attack Vector)

### 시나리오: 쇼핑몰 결제 우회 (Payment Bypass)
**1. 정상 프로세스 분석**
- 해커가 정상적으로 저렴한 물건을 하나 사면서 URL 흐름을 파악함.
- 흐름: `/cart` (장바구니) -> `/order/pay` (결제요청) -> `/order/complete` (주문완료 & DB반영)

**2. 공격 시도 (Forceful Browsing)**
- 비싼 물건을 장바구니에 담음.
- 결제 버튼(`/order/pay`)을 누르지 않고, 주소창에 바로 주문 완료 URL(`/order/complete`)을 입력함.

**3. 검증 부재**
- 서버(`CompleteController`)는 "이 사람이 결제 승인 데이터를 가지고 왔는가?"를 확인하지 않고, 단순히 페이지에 접속했다는 이유만으로 `INSERT INTO ORDER` 쿼리를 날려버림.
- **결과**: 돈 한 푼 안 내고 주문이 성사됨.

---

## 3. 취약한 코드 vs 안전한 코드 (Java/Spring)

핵심은 **"최종 단계에서 이전 단계의 성공 여부(Flag/Token)를 반드시 확인해야 한다"** 는 것.

### ❌ 취약한 코드 (순서 검증 없음)
> 단순히 URL 매핑만 되어 있어서, 주소만 알면 누구나 들어와서 비즈니스 로직을 실행시킬 수 있음.

```java
// OrderController.java
@RequestMapping("/order/complete")
public String orderComplete(HttpSession session, Model model) {
    // 취약점: 결제가 진짜 됐는지 확인하는 로직이 아예 없음.
    // 그냥 장바구니에 있는 거 가져와서 주문 테이블에 박아버림.
    
    Member user = (Member) session.getAttribute("user");
    List<Item> cartItems = cartService.getCart(user.getId());
    
    orderService.createOrder(user, cartItems); // 주문 생성 (공짜 구매 성공)
    cartService.clearCart(user.getId());
    
    return "order/finish";
}
```
### ✅ 안전한 코드 (상태 검증 & 토큰 확인)
> 결제 단계에서 생성된 '검증 토큰'이 없으면 주문 완료 로직을 태우지 않음.
```java
// OrderController.java
@RequestMapping("/order/complete")
public String orderComplete(HttpSession session, @RequestParam String payToken) {
    // 1. 세션에서 결제 진행 상태 확인
    Boolean isPaid = (Boolean) session.getAttribute("IS_PAID_SUCCESS");
    
    if (isPaid == null || !isPaid) {
        // 결제 단계 건너뛰고 옴 -> 차단
        return "redirect:/error/invalid_access";
    }

    // 2. 토큰 유효성 및 금액 재검증 (Double Check)
    if (!paymentService.verifyToken(payToken)) {
        throw new PaymentException("유효하지 않은 결제 정보입니다.");
    }

    // 3. 주문 생성
    orderService.createOrder(session.getAttribute("user"));
    
    // 4. 상태 초기화 (재사용 방지)
    session.removeAttribute("IS_PAID_SUCCESS");
    
    return "order/finish";
}
```

## 4. 대응 방안 (Remediation Checklist)
1. 세션 기반 상태 관리 (State Management):

- 각 프로세스 단계(Step)마다 성공 여부를 세션에 기록한다.

- Step 2 진입 시 Step 1 완료 플래그가 세션에 있는지 확인하고, 없으면 Step 1으로 리다이렉트시킨다.

2. 최종 단계의 무결성 검증:

- 주문 완료나 회원가입 완료 같은 민감한 로직은 단순히 페이지를 보여주는 것(View)과 데이터를 처리하는 것(Action)을 분리해야 한다.

- 특히 결제 금액 변조 등을 막기 위해 PG사에서 넘어온 금액과 DB의 실제 상품 금액을 서버단에서 다시 한번 비교해야 한다.

3. Referer 검증 (보조 수단):

- HTTP Referer 헤더를 확인하여 이전 페이지가 올바른 경로(결제 페이지)인지 확인한다. (단, 프록시 툴로 조작 가능하므로 보조 수단으로만 사용)

