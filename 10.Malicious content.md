# 10. 악성 콘텐츠 (Malicious Content) & 파일 업로드 취약점

## 1. 개요 (Overview)
- **정의**: 공격자가 웹 사이트의 파일 업로드 기능을 악용하여, **실행 가능한 악성 파일(JSP, PHP, ASP, EXE 등)**을 서버에 업로드하고 실행시키는 취약점.
- **위험도**: **최상 (Critical)** / 시스템 장악 (RCE)
- **영향**:
    - **웹쉘(Webshell) 실행**: 웹 브라우저를 통해 서버 명령어를 마음대로 실행.
    - **악성코드 유포지 악용**: 접속한 일반 사용자에게 랜섬웨어 등 감염.
    - **Defacement**: 홈페이지 화면 변조.

> **💡 핵심 원리**
>
> 서버는 사용자가 올린 파일을 '그림'이라고 믿고 싶지만, 해커는 '프로그램(JSP)'을 올려서 실행시킨다.

---

## 2. 공격 메커니즘 (Attack Vector)



### 시나리오: 게시판 이미지 업로드
사용자 프로필 사진을 올리는 기능이 있다고 가정.

**1. 공격 파일 준비 (Webshell)**
- 해커는 `hack.jsp`라는 파일을 만듦.
- 내용: `Runtime.getRuntime().exec(request.getParameter("cmd"));` (명령어 실행 코드)

**2. 업로드 (Upload)**
- 해커가 프로필 사진 대신 `hack.jsp`를 업로드함.
- 서버가 확장자 검사를 안 해서 그대로 `/uploads/hack.jsp` 경로에 저장됨.

**3. 실행 (Execute)**
- 해커가 브라우저 주소창에 `http://site.com/uploads/hack.jsp?cmd=ls` 입력.
- 서버는 이 파일을 **JSP 프로그램으로 인식하고 실행**해버림.
- **결과**: 브라우저 화면에 서버의 파일 목록(`ls` 결과)이 출력됨. (게임 끝)

---

## 3. 취약한 코드 vs 안전한 코드 (Java)

### ❌ 취약한 코드 (검증 없음)
> 파일의 이름이나 내용을 전혀 확인하지 않고 저장함.

```java
// MultipartRequest를 쓰면서 아무런 정책이 없음
MultipartRequest multi = new MultipartRequest(request, savePath, sizeLimit, "utf-8", new DefaultFileRenamePolicy());

// 파일이 .jsp든 .exe든 그냥 저장됨 -> 해킹 성공
File file = multi.getFile("uploadFile");
```

### ✅ 안전한 코드 (3중 방어 시스템)
> ① 확장자(Whitelist) + ② 파일명 변경 + ③ 저장 경로 분리

```java
String fileName = upload.getOriginalFileName();
String ext = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();

// [Step 1] 확장자 화이트리스트 검증 (이미지만 허용)
// 블랙리스트(jsp 막기)는 우회법이 많아서 위험함.
if (!"jpg".equals(ext) && !"png".equals(ext) && !"gif".equals(ext)) {
    file.delete(); // 즉시 삭제
    throw new SecurityException("허용되지 않은 파일 형식입니다.");
}

// [Step 2] 파일명 난수화 (Randomizing)
// 해커가 업로드한 파일을 못 찾게 이름(UUID)을 바꿔버림
String uuid = UUID.randomUUID().toString();
String safeFileName = uuid + "." + ext; // 예: a1b2c3d4.jpg

// [Step 3] 파일 저장 (Web Root 밖으로!)
// 실행 권한이 없는 별도 경로에 저장
File saveFile = new File("C:/secure_uploads/" + safeFileName);
upload.transferTo(saveFile);
```

## 4. 대응 방안 (실무 체크리스트)

1순위: 업로드 경로를 Web Root 밖으로 분리 (가장 확실)
원리: 톰캣의 webapp 폴더(Web Root) 안에 파일을 저장하면, 브라우저에서 URL로 직접 접근(http://.../file.jsp)하여 실행할 수 있음.

조치: 파일을 C:/uploads/나 NAS 같은 웹 서버가 직접 접근할 수 없는 외부 경로에 저장하고, 다운로드 시에는 Stream을 통해 읽어서 전달하는 방식(Download Controller)을 씀. 이러면 .jsp 파일이 올라가도 실행이 안 됨.

2순위: 확장자 화이트리스트 (White-list)
블랙리스트 지양: .jsp, .php만 막으면 .jspx, .JSP, .php5 등으로 우회 가능.

화이트리스트 적용: 반드시 필요한 .jpg, .png, .pdf 등만 허용.

3순위: 파일명 난수화 (Randomizing)
hack.jsp를 29384710.jpg로 이름을 강제로 바꿔서 저장하면, 해커가 스크립트로 실행하기 어려워짐.

4순위: 실행 권한 제거 (Linux)
업로드 폴더 권한을 644 (rw-r--r--) 또는 Run script 권한 제거 설정을 하여, 파일이 있더라도 실행되지 않도록 OS 레벨에서 차단.

## 5. 심화

1. 확장자 우회

단순히 확장자 문자열만 비교하면 우회가 가능하다.

우회 기법: 이중 확장자(hack.jsp.jpg), Null Byte 삽입(hack.jsp%00.jpg), Content-Type 변조.

방어 기법: 파일 시그니처(Magic Number) 검증 필수.

예: .jpg 파일은 반드시 16진수 FF D8 FF로 시작해야 함. Java의 Apache Tika 라이브러리 등을 활용하여 실제 파일 타입을 검증해야 한다.

2. 파일 업로드 취약점과의 차이점

경계가 좀 호모한 부분이긴 하다. 굳이 정확하게 나누어 보려고 한다면, 주통기를 살펴보자.

![alt text](image.png)
10번 항목의 악성 콘텐츠 같은 경우에는, "악성 콘텐츠를 주입하여 실행될 경우 사용자가 해당 콘텐츠 열람 시 악성코드 감염 및 웹 페이지 변조 등 보안상 심각한 위험에 노출될 수 있음" 라고 한다.

포커스가 사용자가 악성 콘텐츠에 노출되지 않게 하는 것에 맞춰져 있다.


![alt text](image-1.png)
22번 항목인 파일 업로드 같은 경우에는 Server Side Script가 업로드 및 실행되지 않게 하는 것에 초점이 맞춰져 있다.

즉 악성 콘텐츠가 사용자에게 흘러 책임소재가 서비스를 제공하는 측에 가지 않게하기 위함이다.

파일 업로드 취약점은 서버가 탈취당하는 것을 막기 위함이다.

이러한 차이가 나는 이유는, 가이드라인의 특성 때문이라고 생각한다. 첨언하자면, 주통기기반 가이드라인은 점검 리스트이다. 점검자가 빠트리지 않고 체크하려면, 피해 대상과 증상에 따라 명확히 분류해야 한다.

> 10. 악성 콘텐츠
>
>방문자가 감염되는가? (사용자 보호)

>22. 파일 업로드
>
>서버 관리자 권한이 털리는가? (서버 보호)

주통기는 순수한 기술 연구 문서가 아닌, **관리와 통제(Governance & Compliance)** 의 성격이 더 강하다.

가술적 관점에서는 원인(Cause) 중심으로 분류하지만, 가이드 라인은 **결과와 관리(Effect & Management)** 중심으로 분류하기 때문이다.

점검과 감사의 편의성, 책임 소재와 대응 우선순위를 위해서 10번 항목과 22번 항목, 그리고 더 나아가 다른 항목들도 나뉘어졌다고 생각하고 믿고있다.

순수 기술적인 관점에서는 두 취약점 모두 **입력값 및 파일 검증 부재**가 원인이다.


필자는 21년도 기준을 비교했다. 2025-12-24일 기준으로 2026년도의 주통기가 나왔으므로 한번 더 비교해보겠다.

![alt text](image-2.png)
두 항목이 합쳐졌다. 악성 파일 업로드라는 이름이 더 잘 어울린다.

기존에는 악성 콘텐츠 -> XSS, File 전부 사용자에게 흘러가지 않게 점검해야 한다. 그리고(다른 항목으로 나뉘어짐) XSS 는 이렇게 막고 File Upload는 이렇게 막아라.

라는 의미 였다면, 
지금은 입력값 검증과 파일 검증의 측면에서 나뉘어진 것 같다.
그러니까 경로를 기준으로 나뉘었다. 

개발자 입장에서는 JSP와 EXE를 막는 코드는 따로 짜지 않는다. 모두 화이트리스트 처리나 검증 로직을 적용할 뿐이다. 이건 개발자 입장 및 기술적 진단자 입장에서 합리적이다. 

26년도 기준의 주통기에서 웹 애플리케이션 취약점 진단 항목들을 살펴보면 취약점 발생 위치 중심의 분류가 된 곳이 많다. 

즉, 기존의 사용자 보호 + 서버 보호 로 나뉘어진 항목이 합쳐졌다고 봐도 무방하다.
FU-14를 달성하면 사용자와 서버 모두 보호받는 셈이다.