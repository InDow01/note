# 10. 악성 콘텐츠 (Malicious Content) & 파일 업로드 취약점

## 1. 개요 (Overview)
- **정의**: 공격자가 웹 사이트의 파일 업로드 기능을 악용하여, **실행 가능한 악성 파일(JSP, PHP, ASP, EXE 등)**을 서버에 업로드하고 실행시키는 취약점.
- **위험도**: **최상 (Critical)** / 시스템 장악 (RCE)
- **영향**:
    - **웹쉘(Webshell) 실행**: 웹 브라우저를 통해 서버 명령어를 마음대로 실행.
    - **악성코드 유포지 악용**: 접속한 일반 사용자에게 랜섬웨어 등 감염.
    - **Defacement**: 홈페이지 화면 변조.

> **💡 핵심 원리**
>
> 서버는 사용자가 올린 파일을 '그림'이라고 믿고 싶지만, 해커는 '프로그램(JSP)'을 올려서 실행시킨다.

---

## 2. 공격 메커니즘 (Attack Vector)



### 시나리오: 게시판 이미지 업로드
사용자 프로필 사진을 올리는 기능이 있다고 가정.

**1. 공격 파일 준비 (Webshell)**
- 해커는 `hack.jsp`라는 파일을 만듦.
- 내용: `Runtime.getRuntime().exec(request.getParameter("cmd"));` (명령어 실행 코드)

**2. 업로드 (Upload)**
- 해커가 프로필 사진 대신 `hack.jsp`를 업로드함.
- 서버가 확장자 검사를 안 해서 그대로 `/uploads/hack.jsp` 경로에 저장됨.

**3. 실행 (Execute)**
- 해커가 브라우저 주소창에 `http://site.com/uploads/hack.jsp?cmd=ls` 입력.
- 서버는 이 파일을 **JSP 프로그램으로 인식하고 실행**해버림.
- **결과**: 브라우저 화면에 서버의 파일 목록(`ls` 결과)이 출력됨. (게임 끝)

---

## 3. 취약한 코드 vs 안전한 코드 (Java)

### ❌ 취약한 코드 (검증 없음)
> 파일의 이름이나 내용을 전혀 확인하지 않고 저장함.

```java
// MultipartRequest를 쓰면서 아무런 정책이 없음
MultipartRequest multi = new MultipartRequest(request, savePath, sizeLimit, "utf-8", new DefaultFileRenamePolicy());

// 파일이 .jsp든 .exe든 그냥 저장됨 -> 해킹 성공
File file = multi.getFile("uploadFile");
```

### ✅ 안전한 코드 (3중 방어 시스템)
> ① 확장자(Whitelist) + ② 파일명 변경 + ③ 저장 경로 분리

```java
String fileName = upload.getOriginalFileName();
String ext = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();

// [Step 1] 확장자 화이트리스트 검증 (이미지만 허용)
// 블랙리스트(jsp 막기)는 우회법이 많아서 위험함.
if (!"jpg".equals(ext) && !"png".equals(ext) && !"gif".equals(ext)) {
    file.delete(); // 즉시 삭제
    throw new SecurityException("허용되지 않은 파일 형식입니다.");
}

// [Step 2] 파일명 난수화 (Randomizing)
// 해커가 업로드한 파일을 못 찾게 이름(UUID)을 바꿔버림
String uuid = UUID.randomUUID().toString();
String safeFileName = uuid + "." + ext; // 예: a1b2c3d4.jpg

// [Step 3] 파일 저장 (Web Root 밖으로!)
// 실행 권한이 없는 별도 경로에 저장
File saveFile = new File("C:/secure_uploads/" + safeFileName);
upload.transferTo(saveFile);
```

## 4. 대응 방안 (실무 체크리스트)

1순위: 업로드 경로를 Web Root 밖으로 분리 (가장 확실)
원리: 톰캣의 webapp 폴더(Web Root) 안에 파일을 저장하면, 브라우저에서 URL로 직접 접근(http://.../file.jsp)하여 실행할 수 있음.

조치: 파일을 C:/uploads/나 NAS 같은 웹 서버가 직접 접근할 수 없는 외부 경로에 저장하고, 다운로드 시에는 Stream을 통해 읽어서 전달하는 방식(Download Controller)을 씀. 이러면 .jsp 파일이 올라가도 실행이 안 됨.

2순위: 확장자 화이트리스트 (White-list)
블랙리스트 지양: .jsp, .php만 막으면 .jspx, .JSP, .php5 등으로 우회 가능.

화이트리스트 적용: 반드시 필요한 .jpg, .png, .pdf 등만 허용.

3순위: 파일명 난수화 (Randomizing)
hack.jsp를 29384710.jpg로 이름을 강제로 바꿔서 저장하면, 해커가 스크립트로 실행하기 어려워짐.

4순위: 실행 권한 제거 (Linux)
업로드 폴더 권한을 644 (rw-r--r--) 또는 Run script 권한 제거 설정을 하여, 파일이 있더라도 실행되지 않도록 OS 레벨에서 차단.

## 5. 심화

1. 확장자 우회

화이트리스트로 꼭 필요한 확장자만을 적용했을 때에도 우회가 가능함. 가령 이중확장자를 이용하거나, 파일 시그니처나 Content Type을 조작하는 경우임. 
이와 같은 경우, 파일의 시그니처를 검증해야 함. 

.jpg의 경우 FF D8 FF로 시작하는 헥사값을 가짐. 확장자 화이트리스트 + 파일 시그니처 화이트리스트를 적용해야 함.

2. 파일 업로드 취약점과의 차이점

경계가 좀 호모한 부분이긴 하다. 굳이 정확하게 나누어 보려고 한다면, 주통기를 살펴보자.

![alt text](image.png)



![alt text](image-1.png)
