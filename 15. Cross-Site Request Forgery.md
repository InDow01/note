# 15. 사이트 간 요청 위조 (Cross-Site Request Forgery, CSRF)

## 1. 개요 (Overview)
- **정의**: 로그인이 된 사용자가 자신의 의지와는 무관하게 **공격자가 의도한 행위(비밀번호 변경, 계좌 이체, 게시글 작성 등)를 서버에 요청**하게 만드는 취약점.
- **위험도**: **상 (High)**
- **영향**:
    - 사용자 계정 정보 변경 (비밀번호 수정).
    - 관리자 권한으로 회원 삭제, 권한 변경 등 관리자 기능 오용.
    - 금전적 피해 (쇼핑몰 결제, 포인트 선물 등).

> **💡 핵심 원리**
>
> "서버는 브라우저가 보낸 요청을 믿는다. 하지만 그 요청이 **사용자가 진짜 원해서 누른 건지, 해커가 누르게 시킨 건지** 구분하지 못하는 점을 악용."

---

## 2. 공격 메커니즘 (Attack Vector)



### 시나리오: 관리자 비밀번호 몰래 바꾸기
관리자가 쇼핑몰 관리자 페이지(`http://shop.com/admin`)에 로그인한 상태라고 가정.

**1. 공격 준비**
- 해커는 자신의 웹사이트나 이메일에 **보이지 않는 이미지 태그**를 심어둠.
- 코드: `<img src="http://shop.com/admin/changePw?newPw=1234" width="0" height="0">`

**2. 함정 발동**
- 관리자가 해커가 보낸 메일을 열거나 해커의 사이트에 접속함.
- 브라우저는 이미지 태그를 읽고 `src` 주소로 자동으로 요청을 보냄.

**3. 요청 위조 (Forgery)**
- 이때, 관리자의 브라우저에 저장된 **세션 쿠키(JSESSIONID)**가 함께 전송됨.
- 서버(쇼핑몰)는 쿠키를 보고 "아, 관리자가 직접 비밀번호를 1234로 바꾸려나 보다"라고 착각하고 변경 처리함.

---

## 3. 취약한 코드 vs 안전한 코드 (Java/JSP)

CSRF 방어의 핵심은 **"요청을 보낸 사람이 진짜 그 페이지에서 버튼을 누른 게 맞는지"** 확인하는 것.

### ❌ 취약한 코드 (검증 없음)
> 단순히 파라미터만 받아서 처리함. 요청이 어디서(Referer) 왔는지, 정당한 토큰이 있는지 확인 안 함.

```java
// change_pw.jsp
String newPw = request.getParameter("newPw");

// 로그인된 사용자라면 묻지도 따지지도 않고 변경
if (session.getAttribute("id") != null) {
    userDao.updatePassword(id, newPw); // 뚫림
}
```

### ✅ 안전한 코드 (CSRF Token 사용)
난수(Token)를 세션에 심어두고, 요청이 들어올 때마다 세션의 토큰과 파라미터의 토큰이 일치하는지 검사함.

Step 1: 폼 생성 시 토큰 발급
```java
<%
    // 랜덤한 토큰 생성 후 세션에 저장
    String csrfToken = UUID.randomUUID().toString();
    session.setAttribute("csrfToken", csrfToken);
%>
<form action="change_pw_proc.jsp" method="POST">
    <input type="hidden" name="token" value="<%=csrfToken%>">
    <input type="password" name="newPw">
    <button type="submit">변경</button>
</form>
```

Step 2: 요청 처리 시 토큰 검증
```java
// change_pw_proc.jsp
String sessionToken = (String) session.getAttribute("csrfToken");
String paramToken = request.getParameter("token");

// 토큰이 없거나 일치하지 않으면 차단
if (sessionToken == null || !sessionToken.equals(paramToken)) {
    throw new SecurityException("비정상적인 접근입니다. (CSRF Detect)");
}

// 일치하면 로직 수행
userDao.updatePassword(id, newPw);
```

## 4. 대응 방안 (Remediation Checklist)
1. CSRF Token 사용 (가장 확실)

모든 POST, PUT, DELETE 요청에 임의의 난수값(Token)을 포함시켜 전송하고 서버에서 검증한다.

Spring Security 사용 시 <security:csrf /> 설정만 켜면 자동으로 적용됨.

2. Referer 검증

request.getHeader("Referer") 값을 확인하여, 요청이 우리 도메인(mysite.com)에서 온 것인지 확인.

단, 브라우저 설정에 따라 Referer가 전송되지 않을 수 있어 보조적인 수단으로 사용.

3. GET 방식의 상태 변경 금지

GET 방식은 조회(Read)에만 사용해야 함.

`<img src="...">` 태그는 GET 요청만 가능하므로, 중요 기능(수정, 삭제)을 POST로만 받게 해도 이미지 태그를 이용한 단순 CSRF는 막을 수 있음.

4. 재인증 (Re-authentication)

비밀번호 변경, 계좌 이체 등 민감한 기능 수행 전 **"비밀번호를 한 번 더 입력하세요"**라고 요구하면 CSRF로 뚫을 수 없음 (해커는 비번을 모르니까).


## 5. 심화

1. SameSite Cookie

최신 브라우저(Chrome 등)에서 지원하는 쿠키 속성으로, CSRF를 막는 강력한 수단.

- SameSite=Strict: 같은 도메인 내에서만 쿠키 전송 허용 (CSRF 원천 차단).
- SameSite=Lax: `<a>` 태그 이동 등 안전한 경우에만 외부 전송 허용 (기본값).

2. 개발자 실수

개발자의 실수가 옴팡지게 일어나는 부분이다.
- 토큰 파라미터 삭제 공격:

요청: POST /changePw Body: pw=1234&token=ABCD (정상)

공격: POST /changePw Body: pw=1234 (token 파라미터 자체를 삭제)

취약점: 서버 코드가 "토큰이 있으면 검사하고, 없으면 그냥 통과"하게 짜여진 경우 뚫림.


- Method 변경 공격:

서버가 POST 요청일 때만 토큰을 검사하도록 설정된 경우.

공격자가 요청을 GET으로 바꿔서 보내면 검증 로직을 건너뛰고 실행되는 경우가 있음.

위 두가지 경우가 토큰을 만들어 놓고 서버측에서 검사를 대충하는 경우에 우회가 발생할 수 도 있다. (우회라기 보다는 그냥 제대로 안한 것..)

3. 토큰 유출

CSRF 토큰을 GET 방식의 URL 파라미터로 넘기는 실수를 할 때 발생. (예: http://shop.com/view?token=a1b2c3d4)

상황: 사용자가 저 페이지에서 외부 사이트(예: 해커 블로그)로 가는 링크를 클릭함.

유출: 해커 서버의 로그(Referer 헤더)에 토큰 값이 그대로 남아서 해커가 줍줍해서 씀.

토큰으로 인증하는 경우에는 토큰을 숨기는 것 까지 필요함 (사실 이것도 개발자 실수..)

4. 예측 가능한 토큰 (Weak Randomness)

토큰이 랜덤값이 아닌 Time(시간)이나 UserID 를 기반으로 단순하게 생성되는 경우, 해커가 몇번 시도해보고 다음 토큰을 예측할 수 있음.

사실 위 경우는 거의 발생하지 않음. 아파치 톰캣 구조에서는 예측 불가능하게 토큰을 생성해주는 기능이 있음.(엔진 자체 취약점이나 랜덤값이 뚫리는 경우는 잘 없다는 뜻)

5. XSS 방어

사실 XSS 가 가능하면 CSRF 는 무조건 가능함. 고로 XSS 방어가 최우선임.

