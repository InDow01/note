# 16. 취약한 세션 예측 (Predictable Session ID)

## 1. 개요 (Overview)
- **정의**: 세션 ID가 추측 가능한 패턴(순차적 숫자, 시간 기반, 특정 규칙 등)으로 생성되어, 공격자가 이를 예측하여 타인의 세션을 가로챌(Session Hijacking) 수 있는 취약점.
- **위험도**: **상 (High)** / 세션 하이재킹 및 계정 탈취
- **영향**:
    - **세션 하이재킹**: 로그인된 다른 사용자의 세션 ID를 예측하여 로그인 없이 해당 사용자로 위장.
    - **권한 상승**: 관리자 세션 ID를 예측하여 시스템 관리자 권한 획득.

> **💡 핵심 원리 (Pattern Recognition)**
>
> "은행 대기표가 100번, 101번, 102번 순서대로 나온다면, 내가 100번을 뽑았을 때 다음 사람의 표가 101번이라는 건 누구나 알 수 있다. 세션 ID가 대기표 같으면 끝장이다."

---

## 2. 공격 메커니즘 (Attack Vector)

### 시나리오: 패턴 분석 및 대입 (Analysis & Brute Force)
**1. 세션 수집 (Collection)**
- 해커가 자신의 계정으로 로그인/로그아웃을 반복하며 서버가 발급하는 세션 ID(쿠키)를 수집한다.
- 예: `SES_001`, `SES_002`, `SES_003`... (극단적 예시)

**2. 패턴 분석 (Analysis)**
- 수집된 ID 간의 규칙성을 분석한다.
- **시간 기반**: `MD5(현재시간)` 형태인지?
- **사용자 정보 기반**: `Base64(User_ID + IP)` 형태인지?
- **PRNG 미흡**: 자바의 기본 `Random()` 함수처럼 예측 가능한 난수 생성기를 썼는지?

**3. 예측 및 공격 (Prediction & Attack)**
- 다음에 생성될(혹은 현재 활동 중일) 세션 ID를 예측하여 생성한다.
- 브라우저 쿠키를 조작하여 예측한 ID(`SES_005`)를 입력하고 페이지를 새로고침한다.
- **결과**: 서버가 해당 세션 ID를 유효하다고 판단하면, 해커는 그 세션의 주인(피해자)으로 로그인된다.

---

## 3. 취약한 코드 vs 안전한 코드 (Java/Tomcat)

이 취약점은 개발자가 **WAS(Tomcat)가 주는 기본 세션을 안 쓰고, 직접 구현하려 할 때** 주로 발생.

### ❌ 취약한 코드 (자체 구현 & 취약한 난수)
> 개발자가 `java.util.Random`이나 시간 값을 이용하여 세션 키를 직접 만드는 경우.

```java
import java.util.Random;

// ...
public String createSessionId(String userId) {
    // 1. 시간 기반 (예측 매우 쉬움)
    long time = System.currentTimeMillis();
    
    // 2. java.util.Random 사용 (선형 합동 생성기 - 예측 가능)
    Random random = new Random();
    int rParam = random.nextInt(99999);
    
    // 이 값을 세션 ID로 사용하면 해커가 쉽게 다음 값을 맞춤
    String mySessionId = "SES_" + time + "_" + rParam; 
    
    // 쿠키에 구워버림
    Cookie sessionCookie = new Cookie("AUTH_TOKEN", mySessionId);
    response.addCookie(sessionCookie);
    
    return mySessionId;
}
```

### ✅ 안전한 코드 (프레임워크/WAS 위임)
세션 ID 생성은 절대 직접 만들지 말고, 검증된 암호화 라이브러리나 WAS의 기능을 사용해야 합니다.

```java
// 방법 1: WAS(Tomcat) 관리 세션 사용 (권장)
// Tomcat은 내부적으로 SecureRandom을 사용하여 JSESSIONID를 안전하게 생성함.
HttpSession session = request.getSession(); // 이미 안전함

// 방법 2: 부득이하게 직접 생성해야 한다면 SecureRandom 사용
import java.security.SecureRandom;
import java.util.Base64;

public String createSafeToken() {
    // 예측 불가능한 난수 생성기 (CSPRNG)
    SecureRandom secureRandom = new SecureRandom();
    byte[] randomBytes = new byte[32]; // 충분한 길이 (256 bit)
    secureRandom.nextBytes(randomBytes);
    
    // Base64 인코딩
    return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
}
```

## 4. 대응 방안 (Remediation Checklist)
1. WAS 제공 세션 관리 사용:

가급적 개발자가 직접 세션 ID를 생성하지 않고, 웹 서버(Tomcat, JBoss 등)가 제공하는 기본 세션 관리 기능(JSESSIONID)을 사용한다. WAS 벤더들은 이미 강력한 알고리즘을 적용해 두었다.

2. 안전한 난수 생성기 사용 (CSPRNG):

토큰을 직접 생성해야 한다면 java.util.Random 대신 암호학적으로 안전한 java.security.SecureRandom 클래스를 사용한다.

- java.util.Random은 통계랑 속도를 위해서 존재함. 간단한 수열 공식을 돌려서(LCG Linear Congruential Generator 알고리즘) 생성됨. 속도가 빠르며 시드값을 알면 재현이 가능함. 이는 Secure Random에서는 구현불가능 함.

3. 충분한 세션 ID 길이 및 복잡도:

세션 ID는 최소 128비트 이상의 길이를 가져야 하며, 알파벳 대소문자, 숫자, 특수문자가 혼합되어 무차별 대입(Brute Force)이 불가능해야 한다.

4. 세션 재발급 (Session Rotation):

로그인 성공 시, 기존에 할당받았던(익명 상태의) 세션 ID를 파기하고 새로운 세션 ID를 발급하여 세션 고정(Session Fixation) 공격도 함께 방어한다.

## 5. 심화 (Deep Dive)

1. 랜덤이라고 다 같은 랜덤이 아니다 (Pseudo-Random vs Secure Random)

개발자들이 가장 많이 하는 실수는 Random() 함수가 '무작위'라고 믿는 것이다.

Pseudo-Random (PRNG): 초기값(Seed)만 알면 이후에 나올 모든 숫자의 순서를 수학적으로 계산해낼 수 있다. (게임 아이템 확률이나 날씨 시뮬레이션용 -> 예를 들어서 마인크래프트에서 맵 시드를 공유하면 같은 맵이 생성되는 것과 같은 원리임.)

Cryptographically Secure PRNG (CSPRNG): OS의 노이즈(마우스 움직임, 하드웨어 인터럽트 등)를 엔트로피(Entropy)로 사용하여 예측이 불가능하다. (보안용)

보안 진단 시, 소스 코드에서 java.util.Random이 인증 토큰 생성에 쓰이고 있다면 100% 취약점으로 잡아야 한다.

2. 심화는 아니고 그냥 경험

초기 진단 프로젝트 진행 시 제공 받은 Web APP에서 보안 조치까지 병행했었는데, UUID 를 발급하는 과정에서 보안조치 때 사용했던 코드임

```java
public static String getRandomString(){
    return UUID.randomUUID().toString().replaceAll("-", "");
}
```

`UUID.randomUUID()` $\rightarrow$ java.security.SecureRandom을 호출해서 자바 내부적으로 만들어내는 코드로 대체했음.

당시 예측가능한 난수, 그러니까 난수에 대해서 조사하였는데, 컴퓨터는 계산기라 완벽한 랜덤은 만들수가 없단다. 컴퓨터공학을 전공했으니 당연하게도 해당사실은 알고 있었으나, CPRNG는 어떻게 만드는 것인지 몰랐다. 조사한 바로는, 

CPRNG를 만들기 위해서 먼저 재료가 필요하다. 최대한 랜덤에 가까운 디지털 신호가 아닌 아날로그에 가까운 신호를 가져오는 것이다. 외부의 노이즈를 긁어오는 것으로 해당 행위를 대체했는데 노이즈란 다음과 같다.

1. 키보드 누르는 시간, 마우스의 미세한 움직임, 하드디스크가 데이터를 읽을 때 나는 기계적 소리/지연 시간, 네트워크 패킷 도착 타이밍 등

이것들을 엔트로피, 즉 무질서하게 나열된 값이라고 생각하고 이를 seed로 취급하는 것이다. seed로 취급했으니 이 값들을 섞는다.

2. 엔트로피 값들을 섞어(mixing, hashing)

sha-256와 같은 해시 함수로 무질서한 값들을 더 무질서하게 만든다.

3. 무질서한 값을 암호화

블록암호(AES)나 스트림 암호 알고리즘을 돌려서 원래 뭐가 들어갔는지 알 수 없게하고, 다음 숫자를 예측하려면 2번의 더 무질서한 값을 알아내야 한다. 근데 그건 SHA-256으로 암호화 되어있는데? 라는 논리로 CPRNG가 생성되게 된다. 
