# 05. SQL Injection (SQL 삽입)

## 1. 개요 (Overview)
- **정의**: 웹 애플리케이션이 외부 입력값을 검증하지 않고 DB 쿼리문(SQL) 생성에 그대로 사용할 때, 공격자가 쿼리의 구조를 조작하여 의도하지 않은 명령을 실행시키는 취약점.
- **위험도**: **최상 (Critical)**
- **영향**:
    - 인증 우회 (로그인 없이 관리자 접속)
    - 데이터 유출 (개인정보 대량 탈취)
    - 데이터 변조/삭제 (Drop Table, Update)
    - 시스템 장악 (xp_cmdshell 등을 이용한 OS 명령어 실행)

> **💡 핵심 원리**
"데이터(Data)"로 들어가야 할 입력값이 "코드(Code)"로 인식되어 실행되는 것.

---

## 2. 공격 메커니즘 (Attack Vector)



### 시나리오: 로그인 우회
사용자 ID와 PW를 받아 로그인을 처리하는 로직.

**1. 정상 쿼리**
```sql
SELECT * FROM users WHERE id = 'user' AND pw = '1234';
```
**2. 공격 입력**

ID 입력값 : ' OR '1'='1

PW 입력값 : 뭐든

**3.완성된 쿼리**
```sql
SELECT * FROM users WHERE id = '' OR '1'='1' AND pw = '...';
```
- 결과 : WHERE 절이 **무조건 참**이 되어, 비밀번호를 몰라도 첫 번째 계정으로 로그인 성공.

## 3. 취약한 코드(State) VS 안전한 코드(Prepared Statement)

### ❌ 취약한 코드 (Statement 사용)
입력값을 문자열 결합(+)으로 연결하여 쿼리를 완성한 후 DB에 전송함.

```java
public User login(String id, String pw) {
    Statement stmt = conn.createStatement();
    // ⚠️ 취약점: 사용자가 입력한 id가 그대로 쿼리문의 일부가 됨
    String query = "SELECT * FROM users WHERE id = '" + id + "' AND pw = '" + pw + "'";
    
    // DB는 완성된 쿼리 문자열을 받아 파싱하고 실행함 -> 조작 가능
    ResultSet rs = stmt.executeQuery(query);
}
```

### ✅ 안전한 코드 (PreparedStatement 사용)
바인딩 (Binding) 쿼리의 구조(틀)를 먼저 정의하고, 입력값은 오직 데이터(?)로만 채워 넣음.
```java
public User loginSecure(String id, String pw) {
    // 1. 쿼리 구조 미리 정의 (Pre-compilation)
    // ? (PlaceHolder)는 나중에 데이터가 들어갈 자리
    String query = "SELECT * FROM users WHERE id = ? AND pw = ?";
    
    PreparedStatement pstmt = conn.prepareStatement(query);
    
    // 2. 데이터 바인딩
    // 입력값에 특수문자(' OR 1=1)가 있어도 단순 '문자열'로 취급됨
    pstmt.setString(1, id);
    pstmt.setString(2, pw);
    
    ResultSet rs = pstmt.executeQuery();
}
```
## 4. Mybatis 주의점

### ❌ 취약한 설정: ${param}
- 달러($)는 String Substitution(문자열 치환) 방식.
- JDBC의 Statement와 동일하게 작동함. (입력값이 쿼리에 그대로 박힘)
- 용도: 테이블명이나 컬럼명을 동적으로 바꿀 때만 써야 함 (데이터 바인딩엔 금지).

```sql
<select id="getUser">
    SELECT * FROM users WHERE id = '${id}'
</select>
```

### ✅안전한 설정: #{param}
- 샵(#)은 PreparedStatement 방식.
- 입력값을 ?로 치환하여 바인딩함.
- SQL Injection 원천 차단.

```sql
<select id="getUser">
    SELECT * FROM users WHERE id = #{id}
</select>
```

## 5. Prepared Statement? MyBatis?

### Prepaerd Statement
DB엔진 자체의 전처리과정에서의 문제.
DB엔진은 쿼리를 받으면 구문 분석(Parsing) -> 최적화 -> 실행 단계를 거침. 

Prepared Statement는 쿼리의 문법 구조를 미리 컴파일 해두고 사용자 입력값은 문법 검사가 끝난 후 단순 데이터로 바인딩함. 따라서 조작어가 있어도 작동하지 않음.

### Mybatis
객체 지향 언어인 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 해주는 개발 프레임워크

SQL 쿼리들을 한 구성파일에 구성하여 프로그램 코드와 SQL을 분리할 수 있는 장점이 있음.


## 6. 핵심 요약 (Key Takeaways)
원인: 사용자 입력값을 검증 없이 쿼리 문자열과 결합(Concatenation)하기 때문.

해결 (Java): Statement 대신 PreparedStatement 사용.

해결 (MyBatis): ${}(치환) 대신 #{}(바인딩) 사용.

예외 처리: 동적 쿼리(Order By 등)가 필수적인 경우, 입력값에 대한 엄격한 화이트리스트 검증 수행.


---
## 7. 심화

> 1. PreparedStatement만 쓰면 되는데 왜 안써요?

여러가지 이유가 있음
1. 데이터는 바인딩되지만, 컬럼명/테이블명은 안됨.

Preparedstatement의 ?(placeholder) 는 값(data)만 들어올 수 있음 식별자(identifier)는 올 수 없음.
예를 들어, 게시판 목록에서 사용자가 선택한 컬럼(title, reg_date, views)으로 정렬(Order by) 해야 할 때.
```sql
// 사용자가 "views"를 선택함
String sql = "SELECT * FROM board ORDER BY ?";
pstmt = conn.prepareStatement(sql);
pstmt.setString(1, "views"); 

// 실행 결과: SELECT * FROM board ORDER BY 'views';
// DB 해석: 'views'라는 문자열 상수 하나로 정렬해라. -> 정렬 안 됨 (변화 없음)
```
?에 들어온 값을 자동으로 따옴표(')로 감싸서 문자열 데이터로 취급해버림. 컬럼명으로 인식할 수 없음.

어쩔수 없이$(columnName)처럼 문자열 치환(Statement)방식을 사용해야함. 이때 취약점이 발생함.

2. 생산성/가독성) 코드가 길어지고 귀찮음 (Developer Experience)

개발자 입장에서 PreparedStatement가 Statement 보다 작성해야 할 코드가 훨씬 많음.
#### Statement
```sql
// 그냥 한 줄에 쭉 쓰면 끝남. 직관적임.
String sql = "INSERT INTO user VALUES ('" + id + "', '" + pw + "', '" + name + "')";
stmt.execute(sql);
```

#### Prepaerdstatement
```sql
// 1. ? 뚫어야 함
String sql = "INSERT INTO user VALUES (?, ?, ?)";
pstmt = conn.prepareStatement(sql);

// 2. 순서 세가면서 하나씩 넣어야 함 (인덱스 실수 잦음)
pstmt.setString(1, id);
pstmt.setString(2, pw);
pstmt.setString(3, name);
pstmt.executeUpdate();
```

3. 디버깅) 완성된 쿼리가 안보임
개발시에 디버깅은 필수적임. 어떤 쿼리가 들어갔길래 값이 이렇게 나오나? 하고 들어간 쿼리를 확인하고 싶은 경우가 많음.

Statement 같은 경우에는 그대로 전문을 찍을 수 있음.
PreparedStatement는 ?로 나옴. 

별도의 설정을 하지 않으면 완성된 쿼리를 확인 할 수 없음. log4jdbc를 사용하면 되지만, 2번과 같은 문제로 귀찮음.


### 그러면 어쩌라고
뭐.. 귀찮아 하지 말고 잘해야죠..
1번의 경우에는 화이트리스트 방식의 문자열 검증이 선행되어야 함.